# -*- coding: utf-8 -*-
"""prova 26-05.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sKaEIwQ0qcuHWXAeBO92ITZNrmbyyPJK
"""

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.metrics import classification_report



# Carregar o CIFAR-10
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.cifar10.load_data()

# Função para filtrar somente gato (3) e cachorro (5)
def filtrar_gato_cachorro(x, y):
    indices = np.where((y == 3) | (y == 5))[0]
    x_filtrado = x[indices]
    y_filtrado = y[indices]
    # Reindexar: gato -> 0, cachorro -> 1
    y_filtrado = np.where(y_filtrado == 3, 0, 1)
    return x_filtrado, y_filtrado

# Aplicar filtro
x_train, y_train = filtrar_gato_cachorro(x_train, y_train)
x_test, y_test = filtrar_gato_cachorro(x_test, y_test)

# Normalizar
x_train = x_train.astype('float32') / 255.0
x_test  = x_test.astype('float32') / 255.0

# Nomes das classes
nomes_classes = ['gato', 'cachorro']

print("x_train:", x_train.shape, "y_train:", y_train.shape)
print("x_test: ", x_test.shape,  "y_test: ",  y_test.shape)

def show_grid(imagens, titulo):
    num = len(imagens)
    rows, cols = 2, 3
    plt.figure(figsize=(15, 8))
    for i, img in enumerate(imagens):
        plt.subplot(rows, cols, i + 1)
        cmap = 'gray' if img.ndim == 2 else None
        plt.imshow(img, cmap=cmap)
        plt.title(f"{titulo} {i+1}")
        plt.axis('off')
    for j in range(num, rows*cols):
        plt.subplot(rows, cols, j + 1)
        plt.axis('off')
    plt.suptitle(titulo, fontsize=20)
    plt.tight_layout(rect=[0,0,1,0.95])
    plt.show()

model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(2, activation='softmax')  # Agora são 2 classes
])

model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

history = model.fit(
    x_train, y_train,
    epochs=5,
    batch_size=64,
    validation_data=(x_test, y_test),
)

# Avaliação no conjunto de teste
test_loss, test_acc = model.evaluate(x_test, y_test, verbose=0)

print("\nAvaliação no conjunto de teste:")
print(f"Acurácia: {test_acc:.4f}")
print(f"Loss: {test_loss:.4f}")

# Gerar relatório de precisão, recall e F1-score
y_pred_probs = model.predict(x_test)
y_pred = np.argmax(y_pred_probs, axis=1)

print("\n Relatório completo de métricas (precisão, recall e F1-score):\n")
relatorio = classification_report(y_test, y_pred, target_names=nomes_classes)
print(relatorio)

# Plot da acurácia
plt.plot(history.history['accuracy'], label='Treinamento')
plt.plot(history.history['val_accuracy'], label='Validação')
plt.xlabel('Épocas')
plt.ylabel('Acurácia')
plt.legend()
plt.title('Desempenho da CNN no CIFAR-10')
plt.grid(True)
plt.show()

pasta_imagens = '/imagens'
nomes = sorted(os.listdir(pasta_imagens))
imagens_processadas = []

for nome in nomes:
    caminho = os.path.join(pasta_imagens, nome)
    img = cv2.imread(caminho)
    if img is None:
        print(f"Erro ao carregar: {caminho}")
        continue

    # Redimensionar para 128x128
    img = cv2.resize(img, (128, 128))

    # Aplicar filtro Gaussiano
    img = cv2.GaussianBlur(img, (5, 5), 0)

    # Converter para tons de cinza
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Equalizar histograma (apenas em escala de cinza)
    img_eq = cv2.equalizeHist(img_gray)

    imagens_processadas.append(img_eq)

if len(imagens_processadas) < 6:
    raise SystemExit("São necessárias pelo menos 6 imagens no diretório /content/imagens.")

# Exibir as imagens processadas
show_grid(imagens_processadas[:6], 'Imagens Pré-processadas (128x128 + Equalização)')

X_minhas = []
for img in imagens_processadas[:6]:
    # Converter imagem de cinza para 3 canais (RGB)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # Redimensionar para 32x32 (entrada da rede) e normalizar
    img32 = cv2.resize(img_rgb, (32, 32))
    img32 = img32.astype('float32') / 255.0
    X_minhas.append(img32)

X_minhas = np.array(X_minhas)

# Fazer predições com o modelo treinado
preds = model.predict(X_minhas)
pred_classes = np.argmax(preds, axis=1)

# Visualizar os resultados
plt.figure(figsize=(18, 6))
for i, (img, pred) in enumerate(zip(X_minhas, pred_classes)):
    plt.subplot(2, 3, i + 1)
    plt.imshow(img)
    plt.title(f'Predição: {nomes_classes[pred]}')
    plt.axis('off')
plt.suptitle('Minhas 6 Imagens Classificadas pelo Modelo (CIFAR-10)', fontsize=20)
plt.tight_layout(rect=[0, 0, 1, 0.92])
plt.show()